#!/usr/bin/python
# -*- coding: UTF-8 -*-
#
#########################################################
# Name: audiomass (main script)
# Porpose:  main audiomass script for command line interface
# Writer: Gianluca Pernigoto <jeanlucperni@gmail.com>
# Copyright: (c) 2015/2016 Gianluca Pernigoto <jeanlucperni@gmail.com>
# license: GPL3
# Version: (Ver.0.6) Febbruary 2015
# Rev
#########################################################

"""
Verify the arguments passed on command line interface.
The arguments are audio files name or path name, these depends
of the passed option type .
"""
import subprocess
import sys
import os
import command_obj
from cli_menu import Appetite
#from datastrings import usage, copying
from datastrings import *


version =  "audiomass-cli v0.6  (https://github.com/jeanslack/audiomass)"

if '-b' in sys.argv or '--batch' in sys.argv:
	
	batch = 'on' 
	
	try:
		if os.path.isdir(sys.argv[2]): 
			path_in = sys.argv[2] # sys.argv[2] is a dir-name if not empty
			
		else:
			usage()
			sys.exit('\n\033[1m Error:\033[0m Invalid path-name\n')
			
	except IndexError: 
		path_in = os.getcwd() # if no dir-name use current work directory
		
		
		
		
		
	
	subprocess.call(['clear'])
		
	main_menu()
		
	input_selection = raw_input("Enter here the corresponding number "
								"and hit enter... "
								)
	
	main = Appetite(None) # not have a ext input = None
	a = main.input_selector(input_selection) # let choice an input format
	input_format = a # return a input format string
	
	if input_selection == 'q' or input_selection == 'Q':
			sys.exit()
	
	elif input_format == None:
			sys.exit("\n\033[1mEntry error in select input format!\033[0m\n")
			
			
			
	graphic_a_format = output_menu()
	new = graphic_a_format[:] # make a new list
	new.remove(graphic_a_format[int(input_selection)]) # remove input format
	 
	
	subprocess.call(['clear'])

	print ('\n\n    The audio input files format is "%s" \n\n'
			'    Please, now type the output files format for '
			'encoding\n' % input_format)
	
	for outformat in new:
		print "    %s"%(outformat)
		
	output_selection = raw_input(
				'\n Type a letter for your encoding and just hit enter: ')
	
	b = main.output_selector(output_selection)
	output_format = b
	
	if output_selection == 'q' or output_selection == 'Q':
			
			sys.exit()
			
	elif output_format == None:
		sys.exit("\n\033[1mEntry error in select output format!\033[0m\n")
		
	
	
	
			
			
			
			
			
			
	
elif '-v' in sys.argv or '--version' in sys.argv:
	print version; sys.exit()
	
elif '-h' in sys.argv or '--help' in sys.argv:
	usage(); sys.exit()
	
elif '-c' in sys.argv or '--copying' in sys.argv:
	copying(); sys.exit()






	
else:
	
	batch = 'off'
	
	supported_formats = {'wav': 1, 'aiff': 2, 'flac': 3, 'ape': 4, 
						'mp3': 5,'ogg': 6
						} 
	try:
		if os.path.isfile(sys.argv[1]):# must be file only here
			path_in = sys.argv[1] # is a file-name

		else:
			usage()
			sys.exit('\n\033[1m Error:\033[0m Invalid file-name\n')
			
	except IndexError:
		
		usage()
		sys.exit('\033[1m Error:\033[0m must be a file\n')
	# input_format is the extension format	of path_in
	input_format = os.path.splitext(path_in)[1].replace(".","")
	
	if supported_formats.has_key(input_format) == False:
		# the file-name must be supported and match with dict keys
		sys.exit('\nSorry, not format supported "%s"\nPlease, choice one of: '
		   '%s\n' % (input_format, supported_formats.keys()))
		
	main = Appetite(input_format) # have a ext input
	main.output_selector(supported_formats[input_format]) #choice an output format
	
# dammi il valore di questa chiave:
command = main.retcode[0] 
# dammi il dizionario per il confronto del fattore di compressione:
dict_bitrate = main.retcode[1]
# dammi il grafico del fattore compressione:
graphic_bitrate = main.retcode[2]
# dialogo immissione fattore di compressione
dialog = main.retcode[3] 
# l'estensione finale dei files convertiti:
codec = main.retcode[4]

#print command
#print dict_bitrate
#print graphic_bitrate
#print dialog
#print codec

if dict_bitrate == None:
	
	command_obj.Process_Conversion(path_in, command, None, batch, codec, 
									input_format)
	
else:
	subprocess.call(['clear'])
		
	print graphic_bitrate
		
	level = raw_input(dialog)
	
	if level == 'c' or level == 'C':
			sys.exit()
			
	a = Appetite(None)
	bitrate = a.quality_level(dict_bitrate, level)
	valid = bitrate
	
	if valid == False:
		
		sys.exit("\n\033[1m Error\033[0m, inexistent quality level\n")

	#print path_in
	#print command
	#print bitrate
	#print batch
	#print codec
	#print input_format

	command_obj.Process_Conversion(path_in, command, bitrate, batch, 
									codec, input_format)
